#include "StateMachineExecutor.h"
#include "Map/MapEntity.h"

namespace Logic 
{

	//---------------------------------------------------------

	//IMP_FACTORY(CStateMachineExecutor);
	RTTI_ROOT_IMPL(CStateMachineExecutor);

	//---------------------------------------------------------

	/**
	Inicialización del componente, utilizando la información extraída de
	la entidad leída del mapa (Maps::CEntity). Toma del mapa el atributo
	behavior, que indica el nombre de la máquina de estado a ejecutar.

	@param entity Entidad a la que pertenece el componente.
	@param map Mapa Lógico en el que se registrará el objeto.
	@param entityInfo Información de construcción del objeto leído del
	fichero de disco.
	@return Cierto si la inicialización ha sido satisfactoria.
	*/
	bool CStateMachineExecutor::spawn(CEntity* entity, CMap *map, const Map::CEntity *entityInfo)
	{
		if(!IComponent::spawn(entity,map,entityInfo))
			return false;

		// Obtiene el nombre de la máquina de estados
		/*if(entityInfo->hasAttribute("behavior")) {
			std::string smName = entityInfo->getStringAttribute("behavior");
			if (_currentStateMachine != 0) delete _currentStateMachine;

			// Saca una instancia de la máquina de estado de la factoría
			_currentStateMachine = AI::CStateMachineFactory::getStateMachine(smName, entity);

			// Creamos la instancia de máquina de estados
			_currentStateMachine = getStateMachine();
		}*/

		// Creamos la instancia de máquina de estados
		_currentStateMachine = getStateMachine();

		return true;
	}

	//---------------------------------------------------------

	/**
	Método llamado en cada frame que actualiza el estado del componente.
	<p>
	Este método actualiza la máquina de estado. Si hay un cambio de estado, 
	se actualiza el valor del atributo _currentAction, que es el que contiene
	la acción latente que se está ejecutando. Por último, se llama al tick de
	la acción latente para que avance su ejecución.

	@param msecs Milisegundos transcurridos desde el último tick.
	*/
	void CStateMachineExecutor::tick(unsigned int msecs)
	{
		IComponent::tick(msecs);

		// TODO PRÁCTICA IA
		// En cada tick del ejecutor de máquinas de estado tenemos que 
		// realizar 2 acciones principales:
		// 1. Actualizar la máquina de estado.
		// 1.1. Si la máquina cambia de estado reseteamos la acción que 
		//		estábamos ejecutando hasta ahora para que se pueda volver
		//		a ejecutar y cambiamos la acción latente actual por la del 
		//		nuevo estado.
		if (_currentStateMachine != NULL) {
			// Si cambiamos de nodo
			if (_currentStateMachine->nextState()) {
				// Dejamos la acción anterior lista para que pueda
				// volver a ser ejecutada
				if (_currentAction != NULL) 
					_currentAction->reset();

				// Sacamos la nueva acción
				_currentAction = _currentStateMachine->getCurrentNode();
			}
		}
		// 2. Ejecutar la acción latente correspondiente al estado actual
		if (_currentAction != NULL) {
			_currentAction->tick();
		}
	}

	//---------------------------------------------------------

	/**
	Este método delega en el método HandleMessage de la acción latente que se
	está ejecutando (_currentAction).
	*/
	bool CStateMachineExecutor::HandleMessage(const WalkSoulPathMessage& msg)
	{
		if (_currentStateMachine != NULL && _currentStateMachine->HandleMessage(msg))
			return true;
		if (_currentAction != NULL)
			return _currentAction->HandleMessage(msg);
		return false;
	}

	bool CStateMachineExecutor::HandleMessage(const HellQuartersMessage& msg)
	{
		if (_currentStateMachine != NULL && _currentStateMachine->HandleMessage(msg))
			return true;
		if (_currentAction != NULL)
			return _currentAction->HandleMessage(msg);
		return false;
	}

	bool CStateMachineExecutor::HandleMessage(const SoulSenderMessage& msg)
	{
		if (_currentStateMachine != NULL && _currentStateMachine->HandleMessage(msg))
			return true;
		if (_currentAction != NULL)
			return _currentAction->HandleMessage(msg);
		return false;
	}

	//---------------------------------------------------------

	/**
	Este método delega en el método accept de la acción latente que se 
	está ejecutando (_currentAction).
	*/
	/*bool CStateMachineExecutor::accept(const TMessage &message)
	{
		// TODO PRÁCTICA IA
		// El método accept delega en el método accept de la acción latente actual
		if (_currentStateMachine != NULL && _currentStateMachine->accept(message))
			return true;
		if (_currentAction != NULL)
			return _currentAction->accept(message);
		return false;
	}*/

	//---------------------------------------------------------

	/**
	Este método delega en el método process de la acción latente que se 
	está ejecutando (_currentAction).
	*/
	/*void CStateMachineExecutor::process(const TMessage &message)
	{
		// TODO PRÁCTICA IA
		// El método process delega en el método process de la acción latente actual
		if (_currentStateMachine != NULL)
			_currentStateMachine->process(message);
		if (_currentAction != NULL) 
			_currentAction->process(message);
	}*/

	//---------------------------------------------------------

}